#!/usr/bin/env ruby
# Encoding: utf-8
#--------------------------------------------------------------------
#  Sifttter Redux
#
#  A modification of Craig Eley's Sifttter that allows for smart
#  installation on a standalone *NIX device (such as a Raspberry Pi).
#
#  Sifttter copyright Craig Eley 2014 <http://craigeley.com>
#
#  Copyright (c) 2014
#  Aaron Bach <bachya1208@gmail.com>
#
#  Permission is hereby granted, free of charge, to any person
#  obtaining a copy of this software and associated documentation
#  files (the "Software"), to deal in the Software without
#  restriction, including without limitation the rights to use,
#  copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the
#  Software is furnished to do so, subject to the following
#  conditions:
#
#  The above copyright notice and this permission notice shall be
#  included in all copies or substantial portions of the Software.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
#  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
#  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
#  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
#  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
#  OTHER DEALINGS IN THE SOFTWARE.
#--------------------------------------------------------------------
require 'gli'
require 'sifttter_redux'
require 'securerandom'

include GLI::App
include SifttterRedux

#  ======================================================
#  App Info
#  ======================================================
program_desc 'Sifttter Redux

    A customized IFTTT-to-Day One service that allows for
    smart installation and automated running on a standalone
    *NIX device (such as a Raspberry Pi).'

version VERSION

#  ======================================================
#  Global Flags and Switches
#  ======================================================
switch([:verbose], desc: 'Turns on verbose output')

#  ======================================================
#  Pre, Post, and Error
#  ======================================================
pre do |global, command, options, args|

  # Load SifttterRedux configuration module.
  Configuration::load(SRD_CONFIG_FILEPATH)

  # Set up logging.
  CLIMessage::activate_logging
  CLIMessage::log_level(Configuration::sifttter_redux[:log_level] || Logger::DEBUG)

  if File.exists?(SRD_CONFIG_FILEPATH)
    current_version = Gem::Version.new(Configuration::sifttter_redux[:version])
    last_config_change_version = Gem::Version.new(NEWEST_CONFIG_VERSION)

    # If the config file needs updating, force the user to do that first.
    if Configuration::sifttter_redux[:version].nil? || current_version < last_config_change_version
      CLIMessage::info('This version needs to make some config changes.')
      CLIMessage::info("Don't worry; when prompted, your current values for")
      CLIMessage::info("existing config options will be presented (so it'll")
      CLIMessage::info('be easier to fly through the upgrade).')
      CLIMessage::prompt('Press enter to continue')
      SifttterRedux::init(true)
      exit!(0)
    end
  else
    # Force the user to init if they try to run any command other than `init` first.
    SifttterRedux::init(true)
    exit!(0)
  end

  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  CLIMessage::error(exception.to_s)
  exit!(1)
  true
end

#  ======================================================
#  Commands
#  ======================================================
#  ------------------------------------------------------
#  exec command
#
#  Executes the script.
#  ------------------------------------------------------
desc 'Execute the script'
command :exec do |c|
  c.flag([:f], desc: 'Run catch-up mode with this start date')
  c.flag([:n], desc: 'Run catch-up mode for the last N days')
  c.flag([:t], desc: 'Run catch-up mode with this end date (must also have -f)')
  c.flag([:w], desc: 'Run catch-up mode for the last N weeks')

  c.switch([:c], desc: 'Run catch-up mode from the beginning of the week to yesterday')
  c.switch([:i], desc: "Include today's date in catch-up")
  c.switch([:verbose], desc: 'Turns on verbose output')
  c.switch([:y], desc: 'Run catch-up mode for yesterday')

  c.action do |global_options, options, args|
    SifttterRedux.verbose = global_options[:verbose] || options[:verbose]

    dates = SifttterRedux::get_dates_from_options(options)
    unless dates.nil?
      first_date = dates.first
      second_date = dates.reverse_each.first

      date_string = first_date.strftime('%B %d, %Y')
      date_string << " to #{ second_date.strftime('%B %d, %Y') }" if first_date != second_date
      CLIMessage::info("Creating #{ first_date == second_date ? 'entry' : 'entries' }: #{ date_string }")

      # Download Sifttter files from Dropbox.
      dbu = DropboxUploader.new(Configuration::db_uploader[:exe_filepath])
      dbu.verbose = SifttterRedux.verbose
      dbu.local_target = Configuration::sifttter_redux[:sifttter_local_filepath]
      dbu.remote_target = Configuration::sifttter_redux[:sifttter_remote_filepath]
      dbu.message = 'Downloading Sifttter files...'

      CLIMessage::info_block(dbu.message || dbu::DEFAULT_MESSAGE, 'Done.', SifttterRedux.verbose) do
        dbu.download
      end

      # Process a new Sifttter entry for each date.
      dates.each do |date|
        Sifttter::run(date)
      end

      # Upload any Day One entries to Dropbox (if there are any).
      unless Dir[Configuration::sifttter_redux[:dayone_local_filepath] + '/*'].empty?
        dbu.local_target = "#{ Configuration::sifttter_redux[:dayone_local_filepath] }/*"
        dbu.remote_target = Configuration::sifttter_redux[:dayone_remote_filepath]
        dbu.message = 'Uploading Day One entries to Dropbox...'

        CLIMessage::info_block(dbu.message || dbu::DEFAULT_MESSAGE, 'Done.', SifttterRedux.verbose) do
          dbu.upload
        end
      end

      # Remove any downloaded local files that we no longer need.
      SifttterRedux::cleanup_temp_files
    end
  end

end

#  ------------------------------------------------------
#  init command
#
#  Initializes the script.
#  ------------------------------------------------------
desc 'Install and SifttterRedux::initialize dependencies'
command :init do |c|
  c.switch([:s], desc: 'Run init from scratch (i.e., clear out all values from configuration)')

  c.action do |global_options, options, args|
    CLIMessage::section_block('INITIALIZING...') do
      if options[:s]
        SifttterRedux::init(true)
      else
        long_message = "You've already initialized Sifttter Redux. Do it again?"
        SifttterRedux::init if CLIMessage::prompt(long_message, 'N').downcase == 'y'
      end
    end
  end
end

exit run(ARGV)
