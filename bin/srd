#!/usr/bin/env ruby
# Encoding: utf-8
#--------------------------------------------------------------------
#  Sifttter Redux
#
#  A modification of Craig Eley's Sifttter that allows for smart
#  installation on a standalone *NIX device (such as a Raspberry Pi).
#
#  Sifttter copyright Craig Eley 2014 <http://craigeley.com>
#
#  Copyright (c) 2014
#  Aaron Bach <bachya1208@gmail.com>
#
#  Permission is hereby granted, free of charge, to any person
#  obtaining a copy of this software and associated documentation
#  files (the "Software"), to deal in the Software without
#  restriction, including without limitation the rights to use,
#  copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the
#  Software is furnished to do so, subject to the following
#  conditions:
#
#  The above copyright notice and this permission notice shall be
#  included in all copies or substantial portions of the Software.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
#  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
#  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
#  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
#  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
#  OTHER DEALINGS IN THE SOFTWARE.
#--------------------------------------------------------------------

require 'fileutils'
require 'gli'
require 'sifttter_redux'

include GLI::App
version SifttterRedux::VERSION
program_desc "Sifttter Redux

    A customized IFTTT-to-Day One service that allows for smart installation
    and automated running on a standalone *NIX device (such as a Raspberry Pi)."

#  ======================================================
#  Global Flags and Switches
#  ======================================================

switch(
  [:verbose],
  :desc => 'Turns on verbose output'
)

#  ======================================================
#  Pre, Post, and Error
#  ======================================================

pre do |global, command, options, args|
  SifttterRedux::Configuration.load(SifttterRedux::SRD_CONFIG_FILEPATH)
  SifttterRedux::DBU.load(File.join(SifttterRedux::Configuration['db_uploader']['local_filepath'], 'dropbox_uploader.sh'))
  
  unless File.exists?(SifttterRedux::SRD_CONFIG_FILEPATH)
    SifttterRedux::CliMessage.info("You haven't initlized Sifttter Redux yet. Doing that now...")
    init
  end

  true
end

#  ======================================================
#  Commands
#  ======================================================

#  ------------------------------------------------------
#  exec command
#
#  Executes the script.
#  ------------------------------------------------------

desc "Execute the script"
command :exec do |c|  
  
  c.flag(
    [:f],
    :desc => "Run catch-up mode with this start date",
  )
  
  c.flag(
    [:n],
    :desc => "Run catch-up mode for the last N days"
  )
    
  c.flag(
    [:t],
    :desc => "Run catch-up mode with this end date (must be accompanied by -f)",
  )
  
  c.flag(
    [:w],
    :desc => "Run catch-up mode for the last N weeks"
  )
  
  c.switch(
    [:c],
    :desc => "Run catch-up mode for the current week (i.e., the beginning of the week to yesterday)"
  )
  
  c.switch(
    [:i],
    :desc => "Include today\"s date in catch-up"
  )

  c.switch(
    [:verbose],
    :desc => 'Turns on verbose output'
  )

  c.switch(
    [:y],
    :desc => "Run catch-up mode for yesterday"
  )
  
  c.action do |global_options, options, args|
    
    SifttterRedux.verbose = global_options[:verbose] || options[:verbose]
    
    SifttterRedux::CliMessage.section_block('EXECUTING...') do
      if options[:c] || options[:n] || options[:w] || options[:y] || options[:f] || options[:t]
    
        command_complete = false
    
        # Current Week
        if !command_complete && options[:c]
          dates = SifttterRedux::DateRangeMaker.last_n_weeks(0, options[:i])
          command_complete = true
        end
      
        # Last N Days
        if !command_complete && options[:n]
          dates = SifttterRedux::DateRangeMaker.last_n_days(options[:n].to_i, options[:i])
          command_complete = true
        end
      
        # Yesterday
        if !command_complete && options[:y]
          dates = SifttterRedux::DateRangeMaker.yesterday
          command_complete = true
        end
      
        # Last N Weeks
        if !command_complete && options[:w]
          dates = SifttterRedux::DateRangeMaker.last_n_weeks(options[:w].to_i, options[:i])
          command_complete = true
        end
      
        # Specific Range
        if !command_complete && (options[:f] || options[:t])
          begin
            dates = SifttterRedux::DateRangeMaker.range(options[:f], options[:t], options[:i])
          
            if dates.last > Date.today
              SifttterRedux::CliMessage.warning("Ignoring overextended end date and using today's date (#{ Date.today })")
              dates = (dates.first..Date.today)
            end
          rescue ArgumentError => e
            SifttterRedux::CliMessage.error(e)
          end
          command_complete = true
        end
      else
        dates = SifttterRedux::DateRangeMaker.today
        command_complete = true
      end
    
      unless dates.nil?
        first_date = dates.first
        second_date = dates.reverse_each.first
      
        if first_date == second_date
          SifttterRedux::CliMessage.info("Creating entry for #{ first_date.strftime("%B %d, %Y") }...")
        else
          SifttterRedux::CliMessage.info("Creating entries for dates from #{ first_date.strftime("%B %d, %Y") } to #{ second_date.strftime("%B %d, %Y") }...")
        end

        SifttterRedux::DBU.set_local_target('/tmp/sifttter')
        SifttterRedux::DBU.set_remote_target('/Apps/ifttt/sifttter')
        SifttterRedux::DBU.set_message('Downloading Sifttter files...')
        SifttterRedux::DBU.download

        dates.each do |date|
          SifttterRedux::Sifttter.run(date)
        end
      
        # Upload any Day One entries to Dropbox (if there are any).
        unless Dir[SifttterRedux::Configuration['sifttter_redux']['dayone_local_filepath'] + "/*"].empty?
          SifttterRedux::DBU.set_local_target("#{SifttterRedux::Configuration['sifttter_redux']['dayone_local_filepath']}/*")
          SifttterRedux::DBU.set_remote_target(SifttterRedux::Configuration['sifttter_redux']['dayone_remote_filepath'])
          SifttterRedux::DBU.set_message('Uploading Day One entries to Dropbox...')
          SifttterRedux::DBU.upload
        end
      
        # Remove any downloaded local files that we no longer need.
        dirs = [
          SifttterRedux::Configuration['sifttter_redux']['dayone_local_filepath'],
          SifttterRedux::Configuration['sifttter_redux']['sifttter_local_filepath']
        ]
      
        SifttterRedux::CliMessage.info_block('Removing temporary local files...') { dirs.each { |d| FileUtils.rm_rf(d) } }
      end
    end
  end
  
end

#  ------------------------------------------------------
#  init command
#
#  Initializes the script.
#  ------------------------------------------------------
desc "Install and initialize dependencies"
command :init do |c|
  c.action do |global_options, options, args|
    
    SifttterRedux::CliMessage.section_block('INITIALIZING...') do
      if File.exists?(SifttterRedux::Configuration.config_path)
        SifttterRedux.init if SifttterRedux::CliMessage.prompt("It looks like you've already initialized Sifttter Redux. Do you want to re-initialize?", "N").downcase == "y"
      else
        SifttterRedux.init
      end
    end
    
  end
end

exit run(ARGV)
