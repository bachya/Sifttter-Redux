#!/usr/bin/env ruby
# Encoding: utf-8
#--------------------------------------------------------------------
#  Sifttter Redux
#
#  A modification of Craig Eley's Sifttter that allows for smart
#  installation on a standalone *NIX device (such as a Raspberry Pi).
#
#  Sifttter copyright Craig Eley 2014 <http://craigeley.com>
#
#  Copyright (c) 2014
#  Aaron Bach <bachya1208@gmail.com>
#
#  Permission is hereby granted, free of charge, to any person
#  obtaining a copy of this software and associated documentation
#  files (the "Software"), to deal in the Software without
#  restriction, including without limitation the rights to use,
#  copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the
#  Software is furnished to do so, subject to the following
#  conditions:
#
#  The above copyright notice and this permission notice shall be
#  included in all copies or substantial portions of the Software.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
#  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
#  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
#  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
#  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
#  OTHER DEALINGS IN THE SOFTWARE.
#--------------------------------------------------------------------

require 'fileutils'
require 'gli'
require 'methadone'
require 'sifttter_redux'

include GLI::App
include Methadone::CLILogging
include SifttterRedux

program_desc 'Sifttter Redux

    A customized IFTTT-to-Day One service that allows for
    smart installation and automated running on a standalone
    *NIX device (such as a Raspberry Pi).'
    
version VERSION

#  ======================================================
#  Global Flags and Switches
#  ======================================================

switch(
  [:verbose],
  desc: 'Turns on verbose output'
)

#  ======================================================
#  Pre, Post, and Error
#  ======================================================

pre do |global, command, options, args|
  # Load SifttterRedux configuration module.
  Configuration.load(SRD_CONFIG_FILEPATH)

  # Load Methadone CLILogging module.
  Methadone::CLILogging.change_logger(Methadone::CLILogger.new(SRD_LOG_FILEPATH, SRD_LOG_FILEPATH))

  # Force the user to initialize if they try to execute first.
  if command.name_for_help[0] == 'exec' && !File.exists?(SRD_CONFIG_FILEPATH)
    CLIMessage.info('You need to initialize Sifttter Redux first...')
    SifttterRedux.init
  end
  
  # Load Dropbox Uploader module.
  DBU.load(File.join(Configuration['db_uploader']['local_filepath'], 'dropbox_uploader.sh')) if File.exists?(SRD_CONFIG_FILEPATH)
  
  true
end

#  ======================================================
#  Commands
#  ======================================================

#  ------------------------------------------------------
#  exec command
#
#  Executes the script.
#  ------------------------------------------------------

desc 'Execute the script'
command :exec do |c|

  c.flag(
    [:f],
    desc: 'Run catch-up mode with this start date'
  )

  c.flag(
    [:n],
    desc: 'Run catch-up mode for the last N days'
  )

  c.flag(
    [:t],
    desc: 'Run catch-up mode with this end date (must also have -f)'
  )

  c.flag(
    [:w],
    desc: 'Run catch-up mode for the last N weeks'
  )

  c.switch(
    [:c],
    desc: 'Run catch-up mode from the beginning of the week to yesterday'
  )

  c.switch(
    [:i],
    desc: "Include today's date in catch-up"
  )

  c.switch(
    [:verbose],
    desc: 'Turns on verbose output'
  )

  c.switch(
    [:y],
    desc: 'Run catch-up mode for yesterday'
  )

  c.action do |global_options, options, args|

    SifttterRedux.verbose = global_options[:verbose] || options[:verbose]

    CLIMessage.section_block('EXECUTING...') do
      if options[:c] || options[:n] || options[:w] || options[:y] || options[:f] || options[:t]

        command_complete = false

        # Current Week
        if !command_complete && options[:c]
          dates = DateRangeMaker.last_n_weeks(0, options[:i])
          command_complete = true
        end

        # Last N Days
        if !command_complete && options[:n]
          dates = DateRangeMaker.last_n_days(options[:n].to_i, options[:i])
          command_complete = true
        end

        # Yesterday
        if !command_complete && options[:y]
          dates = DateRangeMaker.yesterday
          command_complete = true
        end

        # Last N Weeks
        if !command_complete && options[:w]
          dates = DateRangeMaker.last_n_weeks(options[:w].to_i, options[:i])
          command_complete = true
        end

        # Specific Range
        if !command_complete && (options[:f] || options[:t])
          begin
            dates = DateRangeMaker.range(options[:f], options[:t], options[:i])

            if dates.last > Date.today
              CLIMessage.warning("Ignoring overextended end date and using today's date (#{ Date.today })")
              dates = (dates.first..Date.today)
            end
          rescue ArgumentError => e
            CLIMessage.error(e)
          end
        end
      else
        dates = DateRangeMaker.today
      end

      unless dates.nil?
        first_date = dates.first
        second_date = dates.reverse_each.first

        if first_date == second_date
          date_string = first_date.strftime('%B %d, %Y')
          CLIMessage.info("Creating entry for #{ date_string }...")
        else
          date_string = "#{ first_date.strftime('%B %d, %Y') } to #{ second_date.strftime('%B %d, %Y') }"
          CLIMessage.info("Creating entries for dates from #{ date_string }...")
        end

        DBU.local_target = '/tmp/sifttter'
        DBU.remote_target = '/Apps/ifttt/sifttter'
        DBU.message = 'Downloading Sifttter files...'
        DBU.download

        dates.each do |date|
          Sifttter.run(date)
        end

        # Upload any Day One entries to Dropbox (if there are any).
        unless Dir[Configuration['sifttter_redux']['dayone_local_filepath'] + '/*'].empty?
          DBU.local_target = "#{Configuration['sifttter_redux']['dayone_local_filepath']}/*"
          DBU.remote_target = Configuration['sifttter_redux']['dayone_remote_filepath']
          DBU.message = 'Uploading Day One entries to Dropbox...'
          DBU.upload
        end

        # Remove any downloaded local files that we no longer need.
        dirs = [
          Configuration['sifttter_redux']['dayone_local_filepath'],
          Configuration['sifttter_redux']['sifttter_local_filepath']
        ]

        CLIMessage.info_block('Removing temporary local files...') { dirs.each { |d| FileUtils.rm_rf(d) } }
      end
    end
  end

end

#  ------------------------------------------------------
#  init command
#
#  Initializes the script.
#  ------------------------------------------------------
desc 'Install and initialize dependencies'
command :init do |c|
  c.action do |global_options, options, args|
    CLIMessage.section_block('INITIALIZING...') do
      if File.exists?(Configuration.config_path)
        SifttterRedux.init if CLIMessage.prompt("It looks like you've already initialized Sifttter Redux. Do you want to re-initialize?", 'N').downcase == 'y'
      else
        SifttterRedux.init
      end
    end
  end
end

exit run(ARGV)
