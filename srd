#!/usr/bin/env ruby
#-------------------------------------------------------------------------------------------------------------
#  Sifttter Redux
#
#  A modification of Craig Eley's Sifttter that allows for smart installation on a standalone *NIX
#  device (such as a Raspberry Pi).
#
#  Sifttter copyright Craig Eley 2014 <http://craigeley.com>
#
#  Copyright (c) 2014
#  Aaron Bach <bachya1208@gmail.com>
#  
#  Permission is hereby granted, free of charge, to any person
#  obtaining a copy of this software and associated documentation
#  files (the "Software"), to deal in the Software without
#  restriction, including without limitation the rights to use,
#  copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the
#  Software is furnished to do so, subject to the following
#  conditions:
#  
#  The above copyright notice and this permission notice shall be
#  included in all copies or substantial portions of the Software.
#  
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
#  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
#  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
#  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
#  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
#  OTHER DEALINGS IN THE SOFTWARE.
#-------------------------------------------------------------------------------------------------------------

require 'colored'
require 'chronic'
require 'fileutils'
require 'gli'
require 'singleton'
require 'time'
require 'yaml'

#|  ======================================================
#|  CONSTANTS
#|
#|  Don't change these unless you really know
#|  what you're doing.
#|  ======================================================

# Sifttter and Sifttter Redux Constants
SRD_CONFIG_FILEPATH = File.join(ENV['HOME'], '.sifttter_redux')
SFT_LOCAL_FILEPATH = "/tmp/sifttter"
SFT_REMOTE_FILEPATH = "/Apps/ifttt/sifttter"

# Dropbox Upload Constants
DBU_LOCAL_FILEPATH = "/usr/local/opt"

# Day One Constants
DO_REMOTE_FILEPATH = "/Apps/Day\\ One/Journal.dayone/entries"
DO_LOCAL_FILEPATH = "/tmp/dayone"

# Miscellaneous Constants
VERSION = 1.3

#|  ======================================================
#|  CliManager Module
#|  Singleton to manage common CLI interfacing
#|  ======================================================
module CliMessage
  
  ERROR   = 1
  INFO    = 2
  SECTION = 3
  WARNING = 4
  
  #|  ------------------------------------------------------
  #|  error method
  #|
  #|  Outputs a formatted-red error message.
  #|  @param message The message to output
  #|  @return Void
  #|  ------------------------------------------------------
  def self.error(message, addNewline = true)
    if addNewline
      puts "---> ERROR: #{message}".red
    else
      print "---> ERROR: #{message}".red 
    end
    
    @@last_message_type = ERROR
  end
  
  #|  ------------------------------------------------------
  #|  finish_message method
  #|
  #|  Finishes a previous message by appending "DONE" in the
  #|  correct color.
  #|  @return Void
  #|  ------------------------------------------------------
  def self.finish_message(message)
    case @@last_message_type
    when ERROR
      puts message.red
    when INFO
      puts message.blue
    when SECTION
      puts message.green
    when WARNING
      puts message.yellow
    end
  end
  
  #|  ------------------------------------------------------
  #|  info method
  #|
  #|  Outputs a formatted-blue informational message.
  #|  @param message The message to output
  #|  @return Void
  #|  ------------------------------------------------------
  def self.info(message, addNewline = true)
    if addNewline
      puts "---> INFO: #{message}".blue
    else
      print "---> INFO: #{message}".blue 
    end
    
    @@last_message_type = INFO
  end
  
  #|  ------------------------------------------------------
  #|  prompt method
  #|
  #|  Outputs a prompt, collects the user's response, and
  #|  returns it.
  #|  @param prompt The prompt to output
  #|  @param default The default option
  #|  @return String
  #|  ------------------------------------------------------
  def self.prompt(prompt, default)
    print "#{prompt} [default: #{default}]: "
    choice = $stdin.gets.chomp
    if choice.empty?
      return default
    else
      return choice
    end
  end
  
  #|  ------------------------------------------------------
  #|  section method
  #|
  #|  Outputs a formatted-orange section message.
  #|  @param message The message to output
  #|  @return Void
  #|  ------------------------------------------------------
  def self.section(message, addNewline = true)
    if addNewline
      puts "#### #{message}".purple
    else
      print "#### #{message}".purple
    end
    
    @@last_message_type = SECTION
  end
  
  #|  ------------------------------------------------------
  #|  success method
  #|
  #|  Outputs a formatted-green success message.
  #|  @param message The message to output
  #|  @return Void
  #|  ------------------------------------------------------
  def self.success(message, addNewline = true)
    if addNewline
      puts "---> SUCCESS: #{message}".green
    else
      print "---> SUCCESS: #{message}".green
    end
    
    @@last_message_type = WARNING
  end
  
  #|  ------------------------------------------------------
  #|  warning method
  #|
  #|  Outputs a formatted-yellow warning message.
  #|  @param message The message to output
  #|  @return Void
  #|  ------------------------------------------------------
  def self.warning(message, addNewline = true)
    if addNewline
      puts "---> WARNING: #{message}".yellow
    else
      print "---> WARNING: #{message}".yellow
    end
    
    @@last_message_type = WARNING
  end
end

#|  ======================================================
#|  ConfigManager Class
#|
#|  Singleton to manage the YAML config file
#|  for this script
#|  ======================================================
class ConfigManager
  include Singleton
  
  attr_accessor :configFile
  
  #|  ------------------------------------------------------
  #|  initialize method
  #|
  #|  Initializes this singleton with data from the config
  #|  file. If the file doesn't exist, an empty hash is
  #|  created in anticipation of future config saves.
  #|  @return Void
  #|  ------------------------------------------------------
  def initialize
    @configFile = SRD_CONFIG_FILEPATH
    
    if File.exists?(SRD_CONFIG_FILEPATH) 
      @data = YAML.load_file(SRD_CONFIG_FILEPATH)
      @data.each do |k, v|
        define_singleton_method(k) { return v }
      end
    else
      @data = {}
    end
  end
  
  #|  ------------------------------------------------------
  #|  _dump method
  #|
  #|  Convenience method that dumps the configuration hash's
  #|  data.
  #|  @return Void
  #|  ------------------------------------------------------
  def _dump
    puts @data
  end
  
  #|  ------------------------------------------------------
  #|  add_to_section method
  #|
  #|  Adds a hash to the configuration data.
  #|  @param hash The hash to add to configuration
  #|  @param section The section into which the hash goes
  #|  @return Void
  #|  ------------------------------------------------------
  def add_to_section(hash, section)
    unless @data.has_key?(section)
      CliMessage.warning("Attempting to insert into a non-existing section: #{section}; skipping...")
      return 
    end
    
    @data[section].merge!(hash)
  end
  
  #|  ------------------------------------------------------
  #|  create_section method
  #|
  #|  Creates a new section in the configuration hash.
  #|  @param section The section to create
  #|  @return Void
  #|  ------------------------------------------------------
  def create_section(section)
    if @data.has_key?(section)
      CliMessage.warning("Attempting to create existing section (#{section}); skipping...")
      return
    end

    define_singleton_method(section) { return @data[section] }
    @data.merge!(section => {})
  end
  
  #|  ------------------------------------------------------
  #|  delete_section method
  #|
  #|  Deletes a section in the configuration hash.
  #|  @param section The section to delete
  #|  @return Void
  #|  ------------------------------------------------------
  def delete_section(section)
    unless @data.has_key?(section)
      CliMessage.warning("Attempting to delete non-existing section (#{section}); skipping...")
      return
    end
    
    remove_singleton_method(section)
    @data.delete(section)
  end
  
  #|  ------------------------------------------------------
  #|  remove_singleton_method method
  #|
  #|  Removes a hash from the configuration data based on
  #|  its key.
  #|  @param hash The hash key remove
  #|  @param section The section from which the key comes
  #|  @return Void
  #|  ------------------------------------------------------
  def remove_from_section(key, section)
    unless @data.has_key?(section) && @data[section].has_key?(key)
      CliMessage.warning("Attempting to remove a non-existing key: #{section}.#{key}; skipping...")
      return
    end
    
    @data[section].delete(key)
  end
  
  #|  ------------------------------------------------------
  #|  reset method
  #|
  #|  Clears out the configuration data by resetting the hash.
  #|  @return Void
  #|  ------------------------------------------------------
  def reset
    @data = {}
  end
  
  #|  ------------------------------------------------------
  #|  save_configuration method
  #|
  #|  Saves the configuration data to the filesystem.
  #|  @return File
  #|  ------------------------------------------------------
  def save_configuration
    return File.open(@configFile, 'w') { |f| f.write(@data.to_yaml) }
  end
  
end

#|  ======================================================
#|  OS Module
#|
#|  Module to easily find the running operating system
#|  ======================================================
module OS

  #|  ------------------------------------------------------
  #|  linux? method
  #|
  #|  Returns true if the host OS is Linux (false otherwise).
  #|  @return Bool
  #|  ------------------------------------------------------
  def OS.linux?
    OS.unix? and not OS.mac?
  end
  
  #|  ------------------------------------------------------
  #|  mac? method
  #|
  #|  Returns true if the host OS is OS X (false otherwise).
  #|  @return Bool
  #|  ------------------------------------------------------
  def OS.mac?
   (/darwin/ =~ RUBY_PLATFORM) != nil
  end

  #|  ------------------------------------------------------
  #|  unix? method
  #|
  #|  Returns true if the host OS is Unix (false otherwise).
  #|  @return Bool
  #|  ------------------------------------------------------
  def OS.unix?
    !OS.windows?
  end
  
  #|  ------------------------------------------------------
  #|  windows? method
  #|
  #|  Returns true if the host OS is Windows (false otherwise).
  #|  @return Bool
  #|  ------------------------------------------------------
  def OS.windows?
    (/cygwin|mswin|mingw|bccwin|wince|emx/ =~ RUBY_PLATFORM) != nil
  end
end

#|  ======================================================
#|  METHODS
#|  ======================================================

#|  ------------------------------------------------------
#|  collect_catch_up_dates method
#|
#|  Determines the appropriate start and end dates for
#|  Day One entry creation based on GLI flags and switches.
#|  @param method A symbol describing a GLI "scenario"
#|  @param options A Hash of options
#|  @return Range
#|  ------------------------------------------------------
def collect_catch_up_dates(method, options = {})
  _properties = {
    :include_today => false,
    :dates => []
  }
  
  options.each do |k, v|
    k = k.to_sym
    raise ArgumentError, "Unknown property: #{k}" unless _properties.key?(k)
    _properties[k] = v
  end
  
  case method
  when :current
    if _properties[:include_today]
      _r = (Date.today - 7..Date.today)
    else
      _r =  (Date.today - 7...Date.today)
    end
    
    return _r
  when :range
    begin
      chronic_from_date = Chronic.parse(_properties[:dates][0]).to_date
    rescue  
      if (!_properties[:dates][0].nil?)
        CliMessage.error("Please ensure that you are providing valid dates...") 
        return
      end

      nil
    end
    
    begin
      chronic_to_date = Chronic.parse(_properties[:dates][1]).to_date
    rescue
      if (!_properties[:dates][1].nil?)
        CliMessage.error("Please ensure that you are providing valid dates...") 
        return
      end
      
      nil
    end

    if (_properties[:dates][0].nil? && !_properties[:dates][1].nil?)
      CliMessage.error("You can't specify -t without specifying -f...")
      return
    end

    if (!chronic_from_date.nil?)
      if (chronic_to_date.nil?)
        if (_properties[:include_today])
          _r = (chronic_from_date..Date.today)
        else
          _r = (chronic_from_date...Date.today)
        end
      else
        if (chronic_from_date > chronic_to_date)
          CliMessage.error("The start date must be before or equal to the end date...")
          return
        end
        
        if (chronic_to_date > Date.today)
          CliMessage.warning("Ignoring overextended end date and using today's date (#{Date.today}...)")
          chronic_to_date = Date.today
        end
        
        _r = (chronic_from_date..chronic_to_date)
      end
    end
    
    return _r
  when :today
    return (Date.today..Date.today)
  when :yesterday
    return (Date.today - 1..Date.today - 1)
  end
end

#|  ------------------------------------------------------
#|  collect_preferences method
#|
#|  Collects preferences from the user and stores the
#|  entered values into a configuration file.
#|  @return Void
#|  ------------------------------------------------------
def collect_preferences
  CliMessage.section('COLLECTING PREFERENCES...')
  
  pref = CliMessage.prompt("Location for downloaded Sifttter files from Dropbox", SFT_LOCAL_FILEPATH)
  $config.add_to_section({"sifttter_local_filepath" => pref}, "sifttter_redux")
  
  pref = CliMessage.prompt("Location of Sifttter files in Dropbox", SFT_REMOTE_FILEPATH)
  $config.add_to_section({"sifttter_remote_filepath" => pref}, "sifttter_redux")
  
  pref = CliMessage.prompt("Location for downloaded Day One files from Dropbox", DO_LOCAL_FILEPATH)
  $config.add_to_section({"dayone_local_filepath" => pref}, "sifttter_redux")
  
  pref = CliMessage.prompt("Location of Day One files in Dropbox", DO_REMOTE_FILEPATH)
  $config.add_to_section({"dayone_remote_filepath" => pref}, "sifttter_redux")
end

#|  ------------------------------------------------------
#|  download_sifttter_files method
#|
#|  Downloads Sifttter files from Dropbox
#|  @return Void
#|  ------------------------------------------------------
def download_sifttter_files
  # Download all Sifttter files from Dropbox.
  CliMessage.info('Downloading Sifttter files...', false)
  `#{$db_uploader} download #{$config.sifttter_redux["sifttter_remote_filepath"]} #{$config.sifttter_redux["sifttter_local_filepath"]}`
  CliMessage.finish_message('DONE.')
end

#|  ------------------------------------------------------
#|  initialize_procedures method
#|
#|  Initializes Sifttter Redux by downloading and collecting
#|  all necessary items and info.
#|  @return Void
#|  ------------------------------------------------------
def initialize_procedures
  $config.reset
  $config.create_section("sifttter_redux")
  $config.add_to_section({"config_location" => $config.configFile}, "sifttter_redux")
  
  install_db_uploader 
  collect_preferences
  
  CliMessage.section("INITIALIZATION COMPLETE!")
  
  $config.save_configuration
end

#|  ------------------------------------------------------
#|  install_db_uploader method
#|
#|  Installs Dropbox Uploader to a user-specified location
#|  by cloning the git repository.
#|  @return Void
#|  ------------------------------------------------------
def install_db_uploader
  valid_directory_chosen = false
  
  CliMessage.section('DOWNLOADING DROPBOX UPLOADER...')
  
  # Create a new configuration section for Dropbox-Uploader
  $config.create_section("db_uploader")
  
  until valid_directory_chosen
    # Prompt the user for a location to save Dropbox Uploader. "
    db_uploader_location = CliMessage.prompt("Location for Dropbox-Uploader", DBU_LOCAL_FILEPATH)
    db_uploader_location.chop! if db_uploader_location.end_with?('/')
    db_uploader_location = "/usr/local/opt" if db_uploader_location.empty?
    
    # If the entered directory exists, clone the repository.
    if File.directory?(db_uploader_location)
      valid_directory_chosen = true
      db_uploader_location << "/Dropbox-Uploader"
      
      # If, for some reason, Dropbox Uploader alread exists at this location,
      # skip the clone.
      if File.directory?(db_uploader_location)
        CliMessage.info("You seem to already have Dropbox Uploader at this location; skipping...")
      else
        %x{git clone https://github.com/andreafabrizi/Dropbox-Uploader.git #{db_uploader_location}}
      end
      
      # Save config data to YAML.
      $config.add_to_section({"local_filepath" => db_uploader_location}, "db_uploader")
    else
      puts "Sorry, but #{db_uploader_location} isn't a valid directory."
    end
  end
end

#|  ------------------------------------------------------
#|  run_sifttter method
#|
#|  Modified form of Sifttter
#| 
#|  Sifttter: An IFTTT-to-Day One Logger by Craig Eley 2014
#|  Based on tp-dailylog.rb by Brett Terpstra 2012
#|  @param date The date to use when scanning Sifttter files
#|  @return Void
#|  ------------------------------------------------------
def run_sifttter(date)
  uuid_command = "uuidgen" if OS.mac?
  uuid_command = "uuid" if OS.linux?
  uuid = %x{#{uuid_command}}.gsub(/-/,'').strip 
  
  date_for_title = date.strftime('%B %d, %Y')
  datestamp = date.to_time.utc.iso8601
  starred = false

  template = ERB.new <<-XMLTEMPLATE
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
  <plist version="1.0">
  <dict>
  	<key>Creation Date</key>
  	<date><%= datestamp %></date>
  	<key>Entry Text</key>
  	<string><%= entrytext %></string>
  	<key>Starred</key>
  	<<%= starred %>/>
  	<key>Tags</key>
  	<array>
  		<string>daily logs</string>
  	</array>
  	<key>UUID</key>
  	<string><%= uuid %></string>
  </dict>
  </plist>
  XMLTEMPLATE

  date_regex = "#{date.strftime('%B')} 0?#{date.strftime('%-d')}, #{date.strftime('%Y')}"
  time_regex = "\d{1,2}:\d{1,2}\s?[AaPpMm]{2}"

  files = %x{find #{$config.sifttter_redux["sifttter_local_filepath"]} -type f -name '*.txt' | grep -v -i daily | sort}

  projects = []
  files.split("\n").each do |file|
  	if File.exists?(file.strip)
  		f = File.open(file.strip, encoding: 'UTF-8')
  		lines = f.read
  		f.close
  		project = "### " + File.basename(file).gsub(/^.*?\/([^\/]+)$/,"\\1") + "\n"

  		found_completed = false
  		lines.each_line do |line|
  			if line =~ /&/
  				line.gsub!(/[&]/, 'and')
  			end
  			if line =~ /#{date_regex}/
  				found_completed = true
  				project += line.gsub(/@done/,'').gsub(/#{date_regex}\s(-|at)\s/, '').gsub(/#{time_regex}\s-\s/, '').strip + "\n"
  			end
  		end
  	end
  	if found_completed
  		projects.push(project)
  	end
  end
  
  if projects.length <=0
  	CliMessage.error("No entries found...")
    exit!
  end

  if projects.length > 0  
  	entrytext = "# Things done on #{date_for_title}\n\n"
  	projects.each do |project|
  		entrytext += project.gsub(/.txt/, ' ') + "\n\n"
  	end
    
    Dir.mkdir($config.sifttter_redux["dayone_local_filepath"]) if !Dir.exists?($config.sifttter_redux["dayone_local_filepath"])
    
  	fh = File.new(File.expand_path($config.sifttter_redux["dayone_local_filepath"] + "/" + uuid + ".doentry"), 'w+')
  	fh.puts template.result(binding)
  	fh.close
  	CliMessage.success("Entry logged for #{date_for_title}...")
  end
end

#|  ======================================================
#|  Main Program
#|
#|  Bootstraps the CLI and guides the user through use.
#|  ======================================================
include GLI::App
$config = ConfigManager.instance

# Set the description as it will be displayed in the help message
program_desc "Sifttter Redux

    A modification of Craig Eley's Sifttter that allows for smart
    installation on a standalone *NIX device (such as a Raspberry Pi)."
    
version VERSION

#|  ------------------------------------------------------
#|  exec command
#|
#|  Executes the script.
#|  ------------------------------------------------------
pre do |global_options, command, options, args|
  if !File.exists?(SRD_CONFIG_FILEPATH)
    CliMessage.info("It doesn't look like you've initlized Sifttter Redux yet. Doing that now()...")
    initialize_procedures
  end

  $db_uploader = File.join($config.db_uploader["local_filepath"], "dropbox_uploader.sh")
end

desc 'Execute the script'
command :exec do |c|  
  c.flag(
    [:f, :from],
    :desc => 'Run catch-up mode with this start date',
  )
  
  c.flag(
    [:t, :to],
    :desc => 'Run catch-up mode with this end date (must be accompanied by --from)',
  )
  
  c.switch(
    [:c, :current_week],
    :desc => 'Run catch-up mode for the last 7 days'
  )
  
  c.switch(
    [:i, :include_today],
    :desc => 'Include today\'s date in catch-up'
  )
  
  c.switch(
    [:y, :yesterday],
    :desc => 'Run catch-up mode for yesterday'
  )
  
  c.action do |global_options, options, args|
    CliMessage.section('EXECUTING...')
    
    if (options[:c] || options[:y] || options[:f] || options[:t])
      if (options[:c])
        dates = collect_catch_up_dates(:current, {:include_today => options[:i]})
      elsif (options[:y])
        dates = collect_catch_up_dates(:yesterday)
      elsif (options[:f] || options[:t])
        dates = collect_catch_up_dates(:range, {:include_today => options[:i], :dates => [options[:f], options[:t]]})
      end
    else
      dates = collect_catch_up_dates(:today, {:include_today => options[:i]})
    end
    
    download_sifttter_files
    
    if (!dates.nil?)
      CliMessage.info("Creating entries for dates from #{dates.first} to #{dates.last}...")
      dates.each do |date|
        run_sifttter(date)
      end
    else
      exit!
    end
    
    # Upload any Day One entries to Dropbox (if there are any).
    if (!Dir[$config.sifttter_redux["dayone_local_filepath"] + "/*"].empty?)
      CliMessage.info("Uploading Day One entries to Dropbox...", false)
      output = `#{$db_uploader} upload #{$config.sifttter_redux["dayone_local_filepath"] + "/*"} #{$config.sifttter_redux["dayone_remote_filepath"]}`
      CliMessage.finish_message('DONE.')
    end
    
    # Remove any downloaded local files that we no longer need.
    CliMessage.info("Removing downloaded Day One files...", false)
    FileUtils.rm_rf($config.sifttter_redux["dayone_local_filepath"]) if Dir.exists?($config.sifttter_redux["dayone_local_filepath"])
    CliMessage.finish_message('DONE.')
    
    CliMessage.info("Removing downloaded Sifttter files...", false)
    FileUtils.rm_rf($config.sifttter_redux["sifttter_local_filepath"]) if Dir.exists?($config.sifttter_redux["sifttter_local_filepath"])
    CliMessage.finish_message('DONE.')
      
    CliMessage.section('EXECUTION COMPLETE!')
  end
end

#|  ------------------------------------------------------
#|  init command
#|
#|  Initializes the script.
#|  ------------------------------------------------------
desc 'Install and initialize dependencies'
command :init do |c|
  c.action do |global_options, options, args|
    CliMessage.section('INITIALIZING...')

    if File.exists?($config.configFile)
      optionReinitialize = CliMessage.prompt("It looks like you've already initialized Sifttter Redux. Do you want to re-initialize?", "N").downcase
      initialize_procedures if optionReinitialize == 'y'
    else
      initialize_procedures
    end
  end
end

exit run(ARGV)